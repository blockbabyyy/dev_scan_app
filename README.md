# DevScan

Инструмент глубокого поиска файловых сигнатур внутри произвольных контейнеров: папок, ZIP-архивов, бинарных склеек (BIN) и дампов трафика (PCAP).

## Возможности

- **Три движка сканирования**: [Hyperscan](https://github.com/intel/hyperscan) (по умолчанию), [RE2](https://github.com/google/re2), [Boost.Regex](https://www.boost.org/doc/libs/release/libs/regex/)
- **27 типов файлов** из коробки (PDF, ZIP, RAR4/5, PNG, JPG, GIF, BMP, MKV, MP3, OLE, DOC, XLS, PPT, DOCX, XLSX, PPTX, JSON, HTML, XML, EMAIL, 7Z, GZIP, PE, SQLITE, FLAC, WAV)
- **Авто-извлечение архивов** — ZIP/7Z/RAR автоматически распаковываются при сканировании
- **Детектирование вложений** — PNG/JPG внутри DOCX/PPTX показываются в отдельной секции отчёта
- **Коррекция коллизий** — DOCX/XLSX/PPTX автоматически вычитаются из ZIP, DOC/XLS/PPT из OLE
- **Взаимоисключающие сигнатуры** — RAR4/RAR5: показывается только один тип по приоритету
- **Конфигурируемые сигнатуры** — добавляйте свои типы через `signatures.json` или интерактивным визардом `--add-sig`
- **Экспорт результатов** — отчёты в JSON и TXT (`crash_report/report.json`, `crash_report/report.txt`)
- **Логирование** — лог-файл в `crash_report/devscan_YYYYMMDD_HHMMSS.log`
- **Многопоточность** — по умолчанию используются все ядра процессора
- **Бенчмарки** — сравнение производительности движков на сгенерированных датасетах

## Структура проекта

```
DevScan/
├── include/
│   ├── Scanner.h           # Интерфейс Scanner + движки (Boost, RE2, Hyperscan)
│   ├── ConfigLoader.h      # Загрузка сигнатур из JSON
│   ├── TypeMap.h           # build_ext_to_type / build_type_to_ext (по сигнатурам)
│   ├── Logger.h            # Логгер (crash_report/)
│   ├── ReportWriter.h      # Экспорт результатов (JSON/TXT)
│   └── generator/
│       └── Generator.h     # Генератор тестовых датасетов
├── src/
│   ├── Scanner.cpp         # Реализации движков + apply_deduction
│   ├── cli/
│   │   └── main_cli.cpp    # CLI-приложение
│   └── generator/
│       └── Generator.cpp   # Реализация генератора
├── tests/
│   ├── ScannerTests.cpp    # Юнит-тесты (45 тестов)
│   ├── IntegrationTests.cpp# Интеграционные тесты (Folder, ZIP, BIN, PCAP)
│   └── Benchmarks.cpp      # Бенчмарки производительности
├── signatures.json         # База сигнатур
└── CMakeLists.txt
```

После сборки в `out/build/x64-Release/`:

```
bin/        ← DevScanApp.exe, DevScanTests.exe, DevScanBenchmarks.exe
            ← все *.dll зависимости, signatures.json
lib/        ← DevScanCore.lib
pdb/        ← *.pdb (отладочные символы)
CMakeFiles/ ← объектные файлы (CMake internal)
```

## Требования

- C++17
- [CMake](https://cmake.org/) >= 3.21
- [vcpkg](https://vcpkg.io/)
- **CPU**: SSE4.2 для Hyperscan (дефолтный движок); без SSE4.2 использовать `-e re2`
- **ОЗУ**: от 512 MB; для PCAP/файлов > 1 GB рекомендуется ≥ 8 GB
- **Диск**: свободное место ≥ максимальный размер сканируемого ZIP (для извлечения)

### Зависимости (vcpkg)

```bash
vcpkg install hyperscan re2 boost-regex boost-iostreams nlohmann-json gtest benchmark libzip
```

## Сборка

```bash
mkdir build && cd build
cmake .. -DCMAKE_TOOLCHAIN_FILE=<путь_к_vcpkg>/scripts/buildsystems/vcpkg.cmake
cmake --build . --config Release
```

Будут собраны три таргета:

| Таргет | Описание |
|---|---|
| `DevScanApp` | CLI-приложение |
| `DevScanTests` | Юнит- и интеграционные тесты (GTest) |
| `DevScanBenchmarks` | Бенчмарки (Google Benchmark) |

> `signatures.json` автоматически копируется в build-директорию при каждом изменении.

## Использование

### Справка

```bash
DevScanApp.exe --help
DevScanApp.exe --version
```

### Базовый запуск

```bash
bin/DevScanApp.exe <путь_к_папке_или_файлу>
```

### Все опции

```bash
bin/DevScanApp.exe C:/data -e re2 -j 8 --output-json report.json
```

| Опция | Описание |
|---|---|
| `-c, --config <file>` | Путь к файлу сигнатур (по умолчанию: `signatures.json`) |
| `-e, --engine <type>` | Движок: `hs` (Hyperscan, по умолчанию), `re2`, `boost` |
| `-j, --threads <N>` | Количество потоков (по умолчанию: число ядер CPU) |
| `-m, --max-filesize <MB>` | Максимальный размер файла в МБ (по умолчанию: 512) |
| `--output-json <path>` | Сохранить JSON-отчёт по указанному пути |
| `--output-txt <path>` | Сохранить TXT-отчёт по указанному пути |
| `--no-report` | Не генерировать отчёты |
| `--no-extract` | Не извлекать архивы (по умолчанию: авто-извлечение ZIP/7Z/RAR) |
| `--add-sig` | Интерактивный визард для добавления новой сигнатуры |
| `--engine-info` | *(планируется)* Вывести информацию о CPU и рекомендуемый движок |

### Вывод

После сканирования программа:
1. Выводит таблицу результатов в stdout
2. Сохраняет `crash_report/report.json` и `crash_report/report.txt` (если не указано `--no-report`)
3. Пишет лог в `crash_report/devscan_YYYYMMDD_HHMMSS.log`

Пример вывода (сканирование архива с извлечением):

```
[Info] Scanning: C:/data/archive.zip (150 files, 8 threads, engine: Hyperscan)

--- SCAN RESULTS ---
Type            | Count
--------------------------
DOCX            | 10
PDF             | 5
PPTX            | 3
--------------------------
--- EMBEDDED (inside containers) ---
PNG             | 15
JPG             | 5
-----------------------------------
Files processed: 150  (1.23s)
[Reports] crash_report/report.json, crash_report/report.txt
[Log]     crash_report/devscan_20260223_143052.log
```

> **Примечание:** Секция `EMBEDDED` показывает файлы, найденные внутри контейнеров (DOCX/PPTX/ZIP).
> Например, изображения внутри презентаций PowerPoint.

### Формат report.json

```json
{
  "scan_target": "C:/data",
  "engine": "Hyperscan",
  "total_files_processed": 150,
  "detections": {
    "PDF": 10,
    "ZIP": 5,
    "DOC": 3
  },
  "embedded_detections": {
    "PNG": 5,
    "JPG": 2
  }
}
```

## Сигнатуры

Сигнатуры хранятся в `signatures.json` — единственный источник истины для сканера, генератора и маппинга расширений. Каждая запись:

| Поле | Тип | Описание |
|---|---|---|
| `name` | string | Имя типа (например, `"PDF"`) |
| `type` | string | `"binary"` или `"text"` |
| `extensions` | array | Расширения файлов (например, `[".pdf"]`, `[".exe", ".dll"]`, `[]`) |
| `hex_head` | string | Magic bytes начала файла (HEX) |
| `hex_tail` | string | Magic bytes конца файла (HEX, опционально) |
| `text_pattern` | string | Дополнительный regex-якорь для бинарных сигнатур |
| `pattern` | string | Regex-паттерн для текстовых сигнатур (`type: "text"`) |
| `deduct_from` | string | Тип-родитель для вычитания коллизий (опционально) |
| `priority` | int | Приоритет сигнатуры (выше = проверяется первым) |
| `min_file_size` | int | Минимальный размер файла для детекции (защита от FP) |
| `exclusive_with` | array | Взаимоисключающие сигнатуры (например, `["RAR5"]` для RAR4) |

### Пример: бинарная сигнатура

```json
{
  "name": "MY_FORMAT",
  "type": "binary",
  "extensions": [".myf"],
  "hex_head": "4D5A",
  "hex_tail": "00000000"
}
```

### Пример: текстовая сигнатура

```json
{
  "name": "LOG_ERROR",
  "type": "text",
  "extensions": [".log"],
  "pattern": "Error:\\s\\d+"
}
```

### Добавление сигнатуры через визард

```bash
DevScanApp.exe --add-sig
# или с нестандартным конфигом:
DevScanApp.exe --add-sig -c my_sigs.json
```

Визард проведёт по шагам:
1. Ввод имени типа
2. Выбор типа (`binary` / `text`)
3. Путь к sample-файлу для авто-определения magic bytes (или ввод HEX вручную)
4. Опциональное чтение tail-байт из того же файла
5. Regex-якорь для уточнения (опционально)
6. Список расширений через запятую
7. `deduct_from` (опционально)
8. Превью JSON → подтверждение → запись в файл

### Механизм вычитания (deduct_from)

Некоторые форматы являются подмножествами других (DOCX — это ZIP с определённой структурой, DOC — это OLE с маркером `WordDocument`). Поле `deduct_from` автоматически корректирует счётчик родительского типа:

```
ZIP: 15  → после коррекции: 15 - 5(DOCX) - 3(XLSX) - 2(PPTX) = 5
```

> Вычитание однопроходное (плоское). Транзитивные цепочки не поддерживаются.

## Тесты

```bash
# Запуск всех тестов (из папки bin/)
./bin/DevScanTests

# Через CTest (из build-директории)
ctest --test-dir out/build/x64-Release
```

### Набор тестов (45 тестов)

**ScannerTest** — типизированные тесты, запускаются на всех трёх движках (3 × 7 = 21):

| Тест | Описание |
|---|---|
| `Detection_PDF` | Детекция PDF по head + tail |
| `Detection_ZIP` | Детекция ZIP по head |
| `Office_ZIP_And_DOCX_Both_Detected` | DOCX и ZIP одновременно детектируются до вычитания |
| `Empty_Data` | Пустой буфер не даёт совпадений |
| `Single_Byte` | Один байт не даёт совпадений |
| `All_Zeros` | Буфер из нулей не даёт ложных срабатываний |
| `Multiple_PDF_In_Same_Buffer` | Несколько PDF в одном буфере считаются корректно |

**FalsePositiveTest** — тесты на ложные срабатывания, все движки (3 × 3 = 9):

| Тест | Описание |
|---|---|
| `BMP_No_FP_On_Plain_BM` | "BM" без нулевых байт не детектируется как BMP |
| `Email_No_FP_On_Lone_From` | Одиночный "From:" без заголовков не даёт EMAIL |
| `Email_Positive_With_Headers` | Полноценные заголовки детектируются как EMAIL |

**DeductionTest** (2):
- `DOCX_Deducted_From_ZIP` — вычитание DOCX из ZIP корректно
- `Deduction_Does_Not_Go_Negative` — вычитание не уходит в отрицательные значения

**ConfigLoaderTest** (9): загрузка валидных/невалидных конфигов, обработка ошибок.

**IntegrationTest** (4):
- `Folder_Scan_With_Generator` — генерация папки с 50 файлами, проверка всех типов
- `Zip_Archive_Internal_Scan` — генерация ZIP-архива, детекция ZIP-структуры
- `Bin_Concat_Scan` — генерация бинарной склейки (30 файлов), проверка всех типов
- `Pcap_Dump_Scan` — генерация PCAP-дампа (30 файлов), проверка всех типов

## Бенчмарки

Замеры на реальных тестовых файлах. Стенд: AMD Ryzen 7 7700, 16 ядер, Windows 11, NVMe SSD.
Каждый результат — медиана трёх прогонов.

```bash
./bin/DevScanBenchmarks
```

Запускает сравнение Hyperscan, RE2 и Boost.Regex на датасете из 50 файлов (mix=0.2) в режимах 1 и 8 потоков.

### Тестовые наборы

| Набор | Источник | Размер | Файлов |
|-------|----------|-------:|-------:|
| `2026/` | локальный набор | 12 MB | 46 |
| `001.zip` | [digitalcorpora.org — File Corpora](https://digitalcorpora.org/corpora/file-corpora/files/) | 278 MB | 461 |
| `280.zip` | [digitalcorpora.org — File Corpora](https://digitalcorpora.org/corpora/file-corpora/files/) | 292 MB | 345 |
| `001.pcap` | [digitalcorpora.org — Packet Dumps](https://digitalcorpora.org/corpora/packet-dumps/) | 54 MB | 1 |

### Производительность

| Цель | Размер | Движок | j=1 | j=16 | Примечания |
|------|--------|--------|----:|-----:|------------|
| `2026/` | 12 MB, 46 файлов | Hyperscan | 0.33 с | 0.28 с | |
| `2026/` | | RE2 | 0.31 с | 0.20 с | быстрее HS при многопотоке |
| `2026/` | | Boost | 0.46 с | 0.29 с | |
| `001.zip` | 278 MB, 461 файл | Hyperscan | 1.31 с | 1.34 с | ¹ |
| `001.zip` | | RE2 | 2.20 с | 2.02 с | ¹ |
| `001.zip` | | Boost | 11.41 с | 10.37 с | ¹ |
| `280.zip` | 292 MB, 345 файлов | Hyperscan | 1.24 с | 1.27 с | ¹ |
| `280.zip` | | RE2 | 2.25 с | 2.03 с | ¹ |
| `280.zip` | | Boost | 9.22 с | 8.09 с | ¹ |
| `001.pcap` | 54 MB | Hyperscan | 0.60 с | 0.60 с | ² |
| `001.pcap` | | RE2 | 0.55 с | 0.55 с | |
| `001.pcap` | | Boost | 1.65 с | 1.65 с | |

¹ Извлечение файлов из ZIP однопоточно (libzip). Параллельность задействована только для сканирования уже извлечённых файлов, поэтому прирост от j>1 минимален — узкое место I/O.
² При выборе `-e hs` для PCAP движок автоматически заменяется на RE2 (см. раздел о расхождениях ниже). Незначительный оверхед (+0.05 с) — запуск двух экземпляров Scanner (HS + RE2).

**Относительная скорость (001.zip, j=1):** Hyperscan × 1.0 → RE2 × 1.7 → Boost × 8.7

### Точность детектирования

Эталон — Python-скрипт `ref_scan.py`: magic-bytes классификация + рекурсивное извлечение архивов без ограничений.
Все движки запущены с `j=16`. Отклонения от эталона выделены жирным.

#### Таблица 1. `2026/` — папка

| Тип | Ref | Hyperscan | RE2 | Boost |
|-----|----:|----------:|----:|------:|
| DOCX | 12 | 12 | 12 | 12 |
| JPG | 2 (2e) | 2 (2e) | 2 (2e) | **3** (2e) |
| MP3 | 1 | 1 | 1 | 1 |
| PDF | 2 | 2 | 2 | 2 |
| PNG | 24 (20e) | 24 (20e) | 24 (20e) | 24 (20e) |
| PPTX | 2 | 2 | 2 | 2 |
| RAR5 | 2 | 2 | 2 | 2 |

`e` — количество файлов, найденных внутри контейнеров (embedded). Hyperscan и RE2 совпадают с эталоном полностью.

#### Таблица 2. `001.zip` — архив (278 MB)

Для ZIP-архивов `ref_scan.py` возвращает истинное число уникальных файлов каждого типа без ограничений по размеру.
Скан сравнивается по колонке `embedded` (уникальные в пределах лимита 100 MB извлечения).

| Тип | Ref (unique) | HS (emb) | RE2 (emb) | Boost (emb) | Покрытие (HS) |
|-----|-------------:|---------:|----------:|------------:|:-------------:|
| DOC | 80 | 5 | 5 | 5 | 6% |
| EMAIL | 0 | **1** | **1** | **1** | — |
| GIF | 5 | 2 | 2 | 2 | 40% |
| GZIP | 6 | 3 | 3 | 3 | 50% |
| HTML | 21 | 21 | **18** | 21 | 100% |
| JPG | 43 | 23 | 23 | **50** | 53% |
| JSON | 0 | **5** | **4** | **6** | — |
| PDF | 281 | 68 | 68 | 68 | 24% |
| PNG | 2 | 2 | 2 | 2 | 100% |
| PPT | 66 | 23 | 23 | 23 | 35% |
| XLS | 54 | 22 | 22 | 22 | 41% |
| XML | 16 | 6 | 6 | 6 | 38% |
| ZIP | 1 | 1 | 1 | 1 | 100% |

Низкое покрытие (DOC 6%, PDF 24%) — следствие лимита 100 MB: архив распаковывается до исчерпания лимита, остальные файлы не обрабатываются.
EMAIL и JSON в эталоне отсутствуют — ложные срабатывания text-паттернов внутри бинарных файлов (открытая проблема).

#### Таблица 3. `280.zip` — архив (292 MB)

| Тип | Ref (unique) | HS (emb) | RE2 (emb) | Boost (emb) | Покрытие (HS) |
|-----|-------------:|---------:|----------:|------------:|:-------------:|
| DOC | 86 | 24 | 24 | 24 | 28% |
| DOCX | 1 | 0 | 0 | 0 | 0% |
| GIF | 8 | 0 | 0 | 0 | 0% |
| GZIP | 19 | 5 | 5 | **6** | 26% |
| HTML | 28 | **47** | **37** | **47** | >100% |
| JPG | 42 | 5 | 5 | **22** | 12% |
| JSON | 0 | **7** | **7** | **7** | — |
| PDF | 261 | 43 | 43 | 43 | 16% |
| PE | 0 | 0 | 0 | **1** | — |
| PNG | 3 | 0 | 0 | 0 | 0% |
| PPT | 57 | 8 | 8 | 8 | 14% |
| XLS | 26 | 4 | 4 | 4 | 15% |
| XML | 17 | 7 | 7 | 7 | 41% |
| ZIP | 1 | 1 | 1 | 1 | 100% |

HTML >100% у HS и Boost: text-паттерн `<html.*?</html>` срабатывает внутри DOC/DOCX-файлов, содержащих HTML-фрагменты в своей структуре — это не файлы-HTML по magic bytes.
RE2 находит меньше (37 vs 47) из-за бага RE2::Set (id-маппинг фазы 2).
Boost JPG 22 vs HS 5: баг `^`-якоря в Boost (описан ниже).

#### Таблица 4. `001.pcap` — дамп трафика (54 MB)

| Тип | Ref | Hyperscan | RE2 | Boost |
|-----|----:|----------:|----:|------:|
| EMAIL | 297 | 297 | 297 | 297 |
| GIF | 1186 | 1186 | 1186 | 1186 |
| GZIP | 477 | 477 | 477 | 477 |
| HTML | 118 | 118 | 118 | 118 |
| JPG | 1340 | 1340 | 1340 | 1340 |
| JSON | 50 | 50 | 50 | 50 |
| MP3 | 4 | 4 | 4 | 4 |
| PE | 1 | 1 | 1 | 1 |
| PNG | 128 | 128 | 128 | 128 |
| XML | 541 | 541 | 541 | 541 |

Все движки совпадают с эталоном. При `-e hs` RE2 подставляется автоматически (см. ниже).

### Причины расхождений

#### Boost — переизбыток JPG / GZIP / PE

`BoostScanner::scan` ищет паттерны в цикле через `boost::regex_search(cur, end, m, re)`.
После первого совпадения `cur` сдвигается за найденный фрагмент. При следующем вызове
Boost считает новый `cur` «началом строки» (без флагов `match_not_bol | match_prev_avail`),
поэтому `^` в паттерне срабатывает снова.

Дополнительно: в бинарных данных (JPEG, GZIP) встречается байт `0x0A`. Boost по умолчанию
интерпретирует его как конец строки, и `^` совпадает после каждого такого байта в потоке.
В итоге один JPEG-файл (особенно с Exif-thumbnail) даёт 2–3 срабатывания вместо одного.

Исправление запланировано: передача `match_not_bol` после первого совпадения и флаг
`no_mod_newline` при компиляции паттерна.

#### RE2 — недобор HTML (280.zip: −10)

RE2Scanner использует двухфазный подход:
- Фаза 1: `RE2::Set` определяет, какие паттерны присутствуют в файле;
- Фаза 2: `RE2::FindAndConsume` подсчитывает каждый из них.

Если `RE2::Set::Add()` отклоняет один из паттернов, индексы `matched_ids` сдвигаются
относительно вектора регулярных выражений второй фазы. Для части файлов применяется
неверный паттерн — счёт занижается. Исправление запланировано.

#### PCAP — все движки дают одинаковый результат

При `-e hs` для `.pcap`-файлов движок автоматически заменяется на RE2.
Причина: Hyperscan в block-mode сообщает о каждой позиции конца совпадения (end-of-match),
а не о непересекающихся вхождениях. До исправления паттерн `GIF8.*?;` давал 257 592 вместо
реальных 1 186. RE2 `FindAndConsume` даёт корректную семантику непересекающихся совпадений.
Для `-e boost` замена не производится — Boost обрабатывает PCAP напрямую и показывает верный результат.

## Движки сканирования

### Сравнение движков

| Движок | Скорость | Требования к CPU | Ограничение размера файла | Рекомендуется для |
|--------|----------|------------------|--------------------------|-------------------|
| **Hyperscan** (по умолчанию) | ★★★ быстрый | SSE4.2 минимум, AVX2 для полной скорости | **4 GB** (hs_scan: unsigned int) | Много файлов, многоядерная нагрузка |
| **RE2** | ★★ средний | любой x86/ARM | не ограничен (size_t) | Файлы > 4 GB, PCAP, CPU без AVX2 |
| **Boost** | ★ медленный | любой | не ограничен | Отладка паттернов, нестандартные regex |

> **Примечание:** для `.pcap` файлов RE2 используется автоматически, независимо от флага `-e`,
> так как Hyperscan не поддерживает подсчёт непересекающихся совпадений (`unsigned int` size limit
> и семантика end-of-match вместо non-overlapping).

### Требования Hyperscan к CPU

Hyperscan требует как минимум **SSE4.2** (поддерживается большинством процессоров с 2008 года).

Запустить проверку совместимости (**планируется** флаг `--engine-info`):

| CPU | SSE4.2 | AVX2 | Hyperscan |
|-----|--------|------|-----------|
| Intel Core 2008+ (Nehalem) | ✓ | ✗ | работает, базовая скорость |
| Intel/AMD 2013+ (Haswell/Excavator) | ✓ | ✓ | работает с полной скоростью |
| AMD Ryzen 7 7700 (текущая тест-машина) | ✓ | ✓ | работает |
| Intel Atom (ряд моделей), старые ARM | ✗ | ✗ | **не поддерживается** → используйте RE2 |

Если CPU не поддерживает Hyperscan, запустите с `-e re2`:
```bash
DevScanApp.exe /data -e re2
```

### Выбор движка по сценарию

| Сценарий | Рекомендация |
|----------|-------------|
| Сканирование папки, много мелких файлов | Hyperscan (дефолт) |
| Один большой файл > 4 GB | `-e re2` |
| PCAP-дамп любого размера | RE2 используется автоматически |
| ZIP-архив с тысячами файлов | Hyperscan (дефолт) |
| CPU без SSE4.2 / ARM | `-e re2` обязательно |
| Отладка новой сигнатуры | `-e boost` (подробные ошибки regex) |

## Архитектура

### Иерархия Scanner

```
Scanner (abstract)
├── BoostScanner   — Boost.Regex, однопоточный
├── Re2Scanner     — Google RE2, двухфазный (Set-filter + счёт)
└── HsScanner      — Intel Hyperscan, BLOCK-mode
                     ⚠ не потокобезопасен: каждый поток создаёт свой экземпляр
                     ⚠ ограничение: hs_scan принимает unsigned int (max ~4 GB)
```

Создание движка:
```cpp
auto scanner = Scanner::create(EngineType::HYPERSCAN);
scanner->prepare(sigs);           // anchored=true (файлы), false (PCAP)
scanner->scan(data, size, stats); // count_all=false (файлы), true (PCAP)
apply_deduction(stats, sigs);     // из Scanner.h
```

### Режимы сканирования

| Режим | anchored | count_all | Применение |
|-------|----------|-----------|------------|
| Anchored (файлы) | `true` | `false` | Обычные файлы — паттерн ищется с начала (^), один матч на файл |
| Unanchored (PCAP) | `false` | `true` | PCAP-дампы — поиск по всему содержимому, подсчёт всех вхождений |

> Автоматическое переключение в unanchored-режим происходит для файлов с расширением `.pcap`.
> В этом режиме Hyperscan заменяется на RE2 (корректная семантика непересекающихся совпадений).

### Формат ScanStats

```cpp
struct ScanStats {
    std::map<std::string, int> counts;   // тип -> количество
    int total_files_processed = 0;
};
```

## Логирование

| Уровень | Файл | stderr |
|---|---|---|
| `INFO` | да | нет |
| `WARN` | да | да |
| `ERROR` | да | да |

Формат строки лога:

```
[2026-02-23 14:30:52] [INFO] DevScan started
[2026-02-23 14:30:52] [INFO] Loading config: signatures.json
[2026-02-23 14:30:52] [WARN] Skipped: C:/data/locked.bin: permission denied
[2026-02-23 14:30:53] [INFO] Scan complete. Files: 150, time: 1.23s
```

## Лицензия

MIT
